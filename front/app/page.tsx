'use client'

import { useState, useRef, useEffect, useCallback } from 'react'
import React from 'react'
import ReactMarkdown from 'react-markdown'
import remarkGfm from 'remark-gfm'
import rehypeRaw from 'rehype-raw'
import { Send, Plus, User, Bot, Copy, PanelLeft, ChevronDown, ArrowUp, ArrowDown, Trash2, Code } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Switch } from '@/components/ui/switch'
import { Label } from '@/components/ui/label'
import { ThemeToggle } from '@/components/theme-toggle'
import { toast } from 'sonner'
import { cn } from '@/lib/utils'

// API Âü∫Á§é URL - ÊåáÂêëÂêéÁ´ØAPIÊúçÂä°Âô®
const API_BASE_URL = 'http://127.0.0.1:8000'

interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  timestamp: string
}

interface Model {
  id: string
  name: string
  owned_by: string
}

interface ChatHistory {
  id: string
  title: string
  messages: Message[]
  timestamp: string
}

export default function ModernChatGPT() {  const [messages, setMessages] = useState<Message[]>([])
  const [input, setInput] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [selectedModel, setSelectedModel] = useState('gemini-2.0-flash-lite')
  const [models, setModels] = useState<Model[]>([])
  const [chatHistory, setChatHistory] = useState<ChatHistory[]>([])
  const [currentChatId, setCurrentChatId] = useState<string>('')
  const [sidebarOpen, setSidebarOpen] = useState(true)
  const [isAtBottom, setIsAtBottom] = useState(true)
  const [showScrollToBottom, setShowScrollToBottom] = useState(false)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const textareaRef = useRef<HTMLTextAreaElement>(null)
  const scrollContainerRef = useRef<HTMLDivElement>(null)
  
  // API settings
  const [enableSearch, setEnableSearch] = useState(true)
  const [disableHistory, setDisableHistory] = useState(false)
  const [enableMcp, setEnableMcp] = useState(true)
  const [useAgent, setUseAgent] = useState(false)
  const [enableMemory, setEnableMemory] = useState(true)
  const [enableReflection, setEnableReflection] = useState(true)
  const [enableReactMode, setEnableReactMode] = useState(true)
  // API connection status
  const [apiStatus, setApiStatus] = useState<'connected' | 'disconnected' | 'testing'>('disconnected')
  // Raw JSON responses for debugging
  const [rawResponses, setRawResponses] = useState<{[messageId: string]: any}>({})
  const [expandedJson, setExpandedJson] = useState<{[messageId: string]: boolean}>({})  // Auto-scroll and scroll detection
  const scrollToBottom = useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [])

  // ‰ΩøÁî®Èò≤ÊäñÂáΩÊï∞Â§ÑÁêÜÊªöÂä®Ê£ÄÊµãÔºåÂáèÂ∞ë‰∏çÂøÖË¶ÅÁöÑÁä∂ÊÄÅÊõ¥Êñ∞
  const debouncedCheckScrollPosition = useCallback(() => {
    let timeoutId: NodeJS.Timeout | null = null;
    
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      
      timeoutId = setTimeout(() => {
        if (scrollContainerRef.current) {
          const { scrollTop, scrollHeight, clientHeight } = scrollContainerRef.current
          const isNearBottom = scrollHeight - scrollTop - clientHeight < 100
          setIsAtBottom(isNearBottom)
          setShowScrollToBottom(!isNearBottom && messages.length > 0)
        }
        timeoutId = null;
      }, 100); // 100msÈò≤ÊäñÂª∂Ëøü
    };
  }, [messages.length]);

  // ‰ΩøÁî®useRef‰øùÂ≠òÈò≤ÊäñÂáΩÊï∞ÔºåÈÅøÂÖçÊØèÊ¨°Ê∏≤ÊüìÈÉΩÂàõÂª∫Êñ∞ÁöÑÂáΩÊï∞
  const checkScrollPositionRef = useRef(debouncedCheckScrollPosition());
  
  useEffect(() => {
    // Êõ¥Êñ∞Èò≤ÊäñÂáΩÊï∞ÂºïÁî®
    checkScrollPositionRef.current = debouncedCheckScrollPosition();
  }, [debouncedCheckScrollPosition]);

  useEffect(() => {
    if (isAtBottom) {
      scrollToBottom()
    }
  }, [messages, isAtBottom, scrollToBottom])

  useEffect(() => {
    const scrollElement = scrollContainerRef.current
    if (scrollElement) {
      // ‰ΩøÁî®passive: true‰ºòÂåñÊªöÂä®ÊÄßËÉΩ
      scrollElement.addEventListener('scroll', checkScrollPositionRef.current, { passive: true })
      return () => scrollElement.removeEventListener('scroll', checkScrollPositionRef.current)
    }
  }, [])

  // Auto-scroll to bottom when new messages arrive, but only if already at bottom
  useEffect(() => {
    if (isAtBottom) {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
    } else {
      // Â¶ÇÊûú‰∏çÂú®Â∫ïÈÉ®ÔºåÊòæÁ§∫ÊªöÂä®Âà∞Â∫ïÈÉ®ÊåâÈíÆ
      setShowScrollToBottom(messages.length > 0)
    }
  }, [messages, isAtBottom])  // Load models on component mount
  useEffect(() => {
    fetchModels()
    loadChatHistory()
    // ÂºÇÊ≠•Âä†ËΩΩÊúçÂä°Âô®‰ºöËØùÔºà‰∏çÈòªÂ°ûÁïåÈù¢Ôºâ
    loadUserSessionsFromAPI().catch(err => 
      console.warn('‚ö†Ô∏è Failed to load sessions from server:', err)
    )
  }, [])  // Reset current chat ID if no sessions exist (show empty state)
  useEffect(() => {
    // Â¶ÇÊûúÊ≤°Êúâ‰ªª‰Ωï‰ºöËØùÔºåÊ∏ÖÁ©∫ÂΩìÂâç‰ºöËØùID‰ª•ÊòæÁ§∫Á©∫ÁôΩÁä∂ÊÄÅ
    if (chatHistory.length === 0 && currentChatId) {
      console.log('ÔøΩ No sessions exist, showing empty state')
      setCurrentChatId('')
      setMessages([])
    }
  }, [chatHistory])
  // Save chat history to localStorage
  useEffect(() => {
    if (chatHistory.length > 0) {
      localStorage.setItem('chatHistory', JSON.stringify(chatHistory))
    }
  }, [chatHistory])

  // Update chat history when messages change
  useEffect(() => {
    if (currentChatId && messages.length > 0) {
      setChatHistory(prev => 
        prev.map(chat => 
          chat.id === currentChatId 
            ? { ...chat, messages: messages, timestamp: new Date().toISOString() }
            : chat
        )
      )
    }
  }, [messages, currentChatId])
  const fetchModels = async () => {
    try {
      console.log('üîÑ Fetching models from API...')
      setApiStatus('testing')
      
      const response = await fetch(`${API_BASE_URL}/api/v1/models`, {
        headers: {
          'X-API-KEY': API_KEY,
          'accept': 'application/json'
        },
        signal: AbortSignal.timeout(10000) // 10 second timeout for models
      })
      
      console.log(`üìä Models API response status: ${response.status} ${response.statusText}`)
      
      if (!response.ok) {
        const errorText = await response.text()
        console.error('‚ùå Models API Error:', errorText)
        setApiStatus('disconnected')
        
        // Provide specific error messages
        if (response.status === 404) {
          throw new Error('üîç Ê®°ÂûãAPIÁ´ØÈªû‰∏çÂ≠òÂú®ÔºåË´ãÊ™¢Êü•ÂæåÁ´ØAPIÁâàÊú¨')
        } else if (response.status === 401) {
          throw new Error('üîê APIÂØÜÈë∞ÁÑ°ÊïàÔºåË´ãÊ™¢Êü•ÈÖçÁΩÆ')
        } else {
          throw new Error(`‚ùå Áç≤ÂèñÊ®°ÂûãÂ§±Êïó: HTTP ${response.status}`)
        }
      }
        const data = await response.json()
      console.log('‚úÖ Models response:', JSON.stringify(data, null, 2))
      
      // Support different response formats - backend returns ModelListResponse
      const modelsList = data.models || data.data || data || []
        // Validate models data
      if (!Array.isArray(modelsList)) {
        console.warn('‚ö†Ô∏è Models response is not an array:', modelsList)
        throw new Error('üîß Ê®°ÂûãÊï∏ÊìöÊ†ºÂºèÈåØË™§')
      }
      
      setApiStatus('connected')
      
      if (modelsList.length > 0) {
        // Auto-select first model if current selection is invalid
        const validModels = modelsList.filter((model: any) => model.model_id && model.model_name)        
        if (validModels.length > 0) {
          // Convert ModelInfo to our Model interface
          const convertedModels: Model[] = validModels.map((model: any) => ({
            id: model.model_id,
            name: model.model_name,
            owned_by: model.provider || 'unknown'
          }))
          
          // Remove duplicate models based on id
          const uniqueModels = convertedModels.filter((model, index, self) => 
            index === self.findIndex(m => m.id === model.id)
          )
          
          setModels(uniqueModels)
          
          if (!convertedModels.some((model: Model) => model.id === selectedModel)) {
            setSelectedModel(convertedModels[0].id)
            console.log(`üîÑ Model auto-selected: ${convertedModels[0].id}`)
          }
          toast.success(`‚úÖ Â∑≤Âä†Ëºâ ${convertedModels.length} ÂÄãÊ®°Âûã`)
        } else {
          toast.warning('‚ö†Ô∏è Ê≤íÊúâÊúâÊïàÁöÑÊ®°ÂûãÊï∏Êìö')
        }
      } else {
        toast.warning('‚ö†Ô∏è Ê≤íÊúâÂèØÁî®ÁöÑÊ®°Âûã')
        setApiStatus('disconnected')
      }
      
    } catch (error: any) {
      console.error('‚ùå Error fetching models:', error)
      setApiStatus('disconnected')
      
      if (error.name === 'TimeoutError' || error.name === 'AbortError') {
        toast.error('‚è∞ Áç≤ÂèñÊ®°ÂûãË∂ÖÊôÇÔºåË´ãÊ™¢Êü•Á∂≤Áµ°ÈÄ£Êé•')
      } else {
        toast.error(error.message || '‚ùå ÁÑ°Ê≥ïÈÄ£Êé•Âà∞ API ÊúçÂãôÂô®')
      }
      
      // Set fallback models if no models are available
      if (models.length === 0) {
        const fallbackModels = [
          { id: 'gemini-2.0-flash-lite', name: 'Gemini 2.0 Flash Lite', owned_by: 'google' },
          { id: 'gpt-4o-mini', name: 'GPT-4o Mini', owned_by: 'openai' },
          { id: 'claude-3-5-haiku', name: 'Claude 3.5 Haiku', owned_by: 'anthropic' },
          { id: 'llama-3.1-8b', name: 'Llama 3.1 8B', owned_by: 'meta' }
        ]
        setModels(fallbackModels)
        console.log('üîÑ Using fallback models')
        toast.info('üìã ‰ΩøÁî®ÂÇôÁî®Ê®°ÂûãÂàóË°®')      }
    }
  }
  
  const loadChatHistory = () => {
    // Â∞ùËØïÂÖà‰ªéÊúçÂä°Âô®Âä†ËΩΩ‰ºöËØù
    loadChatSessions().catch(() => {
      // Â¶ÇÊûúÊúçÂä°Âô®Âä†ËΩΩÂ§±Ë¥•Ôºå‰ªélocalStorageÂä†ËΩΩ
      const saved = localStorage.getItem('chatHistory')
      if (saved) {
        const parsedHistory = JSON.parse(saved)
        // Âè™ÊúâÂú®ÊúâÊúâÊïà‰ºöËØùÊó∂ÊâçËÆæÁΩÆËÅäÂ§©ÂéÜÂè≤
        if (Array.isArray(parsedHistory) && parsedHistory.length > 0) {
          setChatHistory(parsedHistory)
          console.log('üîÑ Loaded from localStorage as fallback')
        } else {
          console.log('üì≠ No valid sessions in localStorage')
        }
      } else {
        console.log('üì≠ No chat history in localStorage')
      }
    })
  }
    const createNewChat = async () => {
    // Âè™Ê∏ÖÁ©∫ÂΩìÂâçÊ∂àÊÅØÂíå‰ºöËØùIDÔºåÁ≠âÂæÖÁî®Êà∑ÂèëÈÄÅÁ¨¨‰∏ÄÊù°Ê∂àÊÅØÊó∂ÂÜçÂàõÂª∫‰ºöËØù
    setMessages([])
    setCurrentChatId('')
    
    console.log('üÜï Ready for new chat session (will create on first message)')
    toast.success('ÂáÜÂ§áÂºÄÂßãÊñ∞ÂØπËØù')
  }
  const loadChat = async (chat: ChatHistory) => {
    // ËÆæÁΩÆÂΩìÂâç‰ºöËØùID
    setCurrentChatId(chat.id)
    
    // ‰ºòÂÖàÂ∞ùËØï‰ªéÊúçÂä°Âô®Âä†ËΩΩÊúÄÊñ∞Êï∞ÊçÆ
    try {
      await loadSessionDetail(chat.id)
      console.log('‚úÖ Session loaded from server')
    } catch (error) {
      // Â¶ÇÊûúÊúçÂä°Âô®Âä†ËΩΩÂ§±Ë¥•Ôºå‰ΩøÁî®Êú¨Âú∞ÁºìÂ≠ò
      console.warn('‚ö†Ô∏è Failed to load from server, using local cache')
      setMessages(chat.messages)
    }
  }
  const deleteChat = async (chatId: string) => {
    // Â∞ùËØï‰ªéÊúçÂä°Âô®Âà†Èô§
    try {
      await deleteSessionFromServer(chatId)
    } catch (error) {
      // Â¶ÇÊûúÊúçÂä°Âô®Âà†Èô§Â§±Ë¥•ÔºåÊâßË°åÊú¨Âú∞Âà†Èô§
      console.warn('‚ö†Ô∏è Server delete failed, deleting locally')
      setChatHistory(prev => prev.filter(chat => chat.id !== chatId))
      if (currentChatId === chatId) {
        setMessages([])
        setCurrentChatId('')      }
      toast.success('ÂØπËØùÂ∑≤Âà†Èô§')
    }
  }
  
  const sendMessage = async () => {
    if (!input.trim() || isLoading) return

    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: input.trim(),
      timestamp: new Date().toISOString()
    }

    setMessages(prev => [...prev, userMessage])
    setInput('')
    setIsLoading(true)

    try {
      // Â¶ÇÊûúÊ≤°ÊúâÂΩìÂâç‰ºöËØùIDÔºåÂÖàÂàõÂª∫Êñ∞‰ºöËØù
      let sessionId = currentChatId
      let isNewSession = false
      
      if (!sessionId) {
        console.log('üÜï No current session, creating new one...')
        sessionId = await createNewSession()
        setCurrentChatId(sessionId)
        isNewSession = true
        
        // ÂàõÂª∫Êñ∞‰ºöËØùÂØπË±°Âπ∂Ê∑ªÂä†Âà∞‰ºöËØùÂéÜÂè≤‰∏≠
        const newChatHistory: ChatHistory = {
          id: sessionId,
          title: "Êñ∞ÂØπËØù",
          messages: [],
          timestamp: new Date().toISOString()
        }
        
        setChatHistory(prev => [newChatHistory, ...prev])
        console.log('‚úÖ New session created and added to history:', sessionId)
      } else {
        console.log('üìù Using existing session:', sessionId)
      }const endpoint = useAgent 
        ? `${API_BASE_URL}/api/v1/agent/`
        : `${API_BASE_URL}/api/v1/chat/completions`

      console.log('üéØ API endpoint:', endpoint)
      console.log('üîß useAgent state:', useAgent)
      
      // Build request body using enhanced builder with session support
      const body = await buildRequestBodyWithSession([...messages, userMessage], sessionId)// Make API request with retry logic
      const data = await makeApiRequest(endpoint, body)
      
      // ÂºÇÊ≠•Ëß£ÊûêÂìçÂ∫îÔºåÈÅøÂÖçÈòªÂ°ûUI
      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: 'Ê≠£Âú®Â§ÑÁêÜÂìçÂ∫î...', // ‰∏¥Êó∂ÂÜÖÂÆπ
        timestamp: new Date().toISOString()
      }

      // ÂÖàÊòæÁ§∫‰∏¥Êó∂Ê∂àÊÅØÔºåÈÅøÂÖçÁ≠âÂæÖ
      setMessages(prev => [...prev, assistantMessage])
      
      // ÂºÇÊ≠•Â§ÑÁêÜÂìçÂ∫îÂÜÖÂÆπ
      setTimeout(() => {        try {
          const assistantContent = parseApiResponse(data, useAgent)
          
          // Á°Æ‰øù assistantContent ÊòØÂ≠óÁ¨¶‰∏≤
          const finalContent = typeof assistantContent === 'string' 
            ? assistantContent 
            : JSON.stringify(assistantContent)
          
          // Êõ¥Êñ∞Ê∂àÊÅØÂÜÖÂÆπ
          setMessages(prev => prev.map(msg => 
            msg.id === assistantMessage.id 
              ? { ...msg, content: finalContent }
              : msg
          ))
          
          // ‰øùÂ≠òÂéüÂßãÂìçÂ∫îÊï∞ÊçÆÁî®‰∫éË∞ÉËØï (ÈôêÂà∂Êï∞ÈáèÈò≤Ê≠¢ÂÜÖÂ≠òÊ≥ÑÊºè)
          setRawResponses(prev => {
            const newResponses = {
              ...prev,
              [assistantMessage.id]: data
            }
            
            // Âè™‰øùÁïôÊúÄËøë20Êù°ÂìçÂ∫îÔºåÈò≤Ê≠¢ÂÜÖÂ≠òÊ≥ÑÊºè
            const responseIds = Object.keys(newResponses)
            if (responseIds.length > 20) {
              const idsToKeep = responseIds.slice(-20) // ‰øùÁïôÊúÄÊñ∞ÁöÑ20Êù°
              const filteredResponses: {[key: string]: any} = {}
              idsToKeep.forEach(id => {
                filteredResponses[id] = newResponses[id]
              })
              return filteredResponses
            }
            
            return newResponses
          })
          
        } catch (parseError) {
          console.error('‚ùå Error parsing response:', parseError)
          setMessages(prev => prev.map(msg => 
            msg.id === assistantMessage.id 
              ? { ...msg, content: 'ÂìçÂ∫îËß£ÊûêÂ§±Ë¥•ÔºåËØ∑Êü•ÁúãÂéüÂßãJSON' }
              : msg
          ))
        }
      }, 10) // 10msÂª∂ËøüÔºåËÆ©UIÂÖàÊõ¥Êñ∞
        // ËÆæÁΩÆÂΩìÂâç‰ºöËØùIDÔºàÂ¶ÇÊûúÊòØÊñ∞‰ºöËØùÔºâ
      if (!currentChatId) {
        setCurrentChatId(sessionId)
      }

      console.log('‚úÖ Message sent successfully to session:', sessionId)
      toast.success(`${useAgent ? 'Agent' : 'ËÅäÂ§©'}ÈüøÊáâÂ∑≤Êî∂Âà∞`)
      
    } catch (error) {
      console.error('‚ùå Error sending message:', error)
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: `‚ùå ÈåØË™§: ${error instanceof Error ? error.message : 'ÁôºÁîüÊú™Áü•ÈåØË™§'}\n\nüîß Ë®∫Êñ∑‰ø°ÊÅØÔºö\n‚Ä¢ ÂæåÁ´ØÊúçÂãô: ${API_BASE_URL}\n‚Ä¢ API Ê®°Âºè: ${useAgent ? 'Agent' : 'Chat'}\n‚Ä¢ ÊâÄÈÅ∏Ê®°Âûã: ${selectedModel}\n‚Ä¢ API ÂØÜÈë∞: ${API_KEY}\n\nüìã Ë´ãÊ™¢Êü•Ôºö\n1. ÂæåÁ´ØÊúçÂãôÊòØÂê¶Âú® ${API_BASE_URL} ÈÅãË°å\n2. API Á´ØÈªûÊòØÂê¶Ê≠£Á¢∫ÈÖçÁΩÆ\n3. Ê®°ÂûãÊòØÂê¶ÂèØÁî®\n4. Á∂≤Áµ°ÈÄ£Êé•ÊòØÂê¶Ê≠£Â∏∏\n\nüí° ÊèêÁ§∫: ÊÇ®ÂèØ‰ª•ÈªûÊìäÂÅ¥ÈÇäÊ¨ÑÁöÑ"Ê∏¨Ë©¶"ÊåâÈàïÊ™¢Êü•ÈÄ£Êé•ÁãÄÊÖã`,
        timestamp: new Date().toISOString()
      }
      setMessages(prev => [...prev, errorMessage])
      toast.error(`ÁôºÈÄÅ${useAgent ? 'Agent' : 'ËÅäÂ§©'}Ë´ãÊ±ÇÂ§±Êïó`)
    } finally {
      setIsLoading(false)
      abortControllerRef.current = null
    }
  }
  
  const [isComposing, setIsComposing] = useState(false)
  const [compositionText, setCompositionText] = useState('')
  const isComposingRef = useRef(false) // ‰ΩøÁî® ref Á°Æ‰øùÂÆûÊó∂Áä∂ÊÄÅ
  
  // Safari ÊµèËßàÂô®Ê£ÄÊµãÂíåÁâπÊÆäÂ§ÑÁêÜ
  const isSafari = useRef(false)
  useEffect(() => {
    isSafari.current = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
    console.log('üçé Safari detected:', isSafari.current)
  }, [])
  
  const handleKeyDown = (e: React.KeyboardEvent) => {
    // Safari ÁâπÊÆäÂ§ÑÁêÜÔºöÊ£ÄÊü• keyCode 229 (ËæìÂÖ•Ê≥ïÊøÄÊ¥ª)
    if (isSafari.current && e.nativeEvent.keyCode === 229) {
      console.log('üçé Safari IME active (keyCode 229) - blocking Enter')
      return // ‰∏çÂ§ÑÁêÜ‰ªª‰ΩïÊåâÈîÆ
    }
    
    // ÂØπ‰∫é‰∏≠ÊñáËæìÂÖ•Ê≥ïÔºåÈúÄË¶ÅÊ£ÄÊü•Â§ö‰∏™Êù°‰ª∂
    const isEnterPressed = e.key === 'Enter'
    const isNoShift = !e.shiftKey
    const isNotComposing = !isComposing && !isComposingRef.current
    
    console.log('KeyDown event:', { 
      key: e.key, 
      isComposing, 
      isComposingRef: isComposingRef.current,
      shiftKey: e.shiftKey,
      compositionText,
      inputLength: input.length,
      willSend: isEnterPressed && isNoShift && isNotComposing
    })
    
    // Âè™ÊúâÂú®‰∏çÊòØÁªÑÂêàËæìÂÖ•Áä∂ÊÄÅ‰∏ãÊâçÂÖÅËÆ∏ÂèëÈÄÅ
    if (isEnterPressed && isNoShift && isNotComposing) {
      e.preventDefault()
      console.log('‚úÖ Sending message via Enter key')
      sendMessage()
    } else if (isEnterPressed && (isComposing || isComposingRef.current)) {
      console.log('üö´ Enter blocked - composition in progress')
    }
  }
  const handleCompositionStart = (e: React.CompositionEvent) => {
    console.log('üéØ Composition started - ËæìÂÖ•Ê≥ïÂºÄÂßã', e.data)
    setIsComposing(true)
    isComposingRef.current = true
    setCompositionText(e.data || '')
  }

  const handleCompositionUpdate = (e: React.CompositionEvent) => {
    console.log('üîÑ Composition update - ËæìÂÖ•Ê≥ïÊõ¥Êñ∞', e.data)
    setCompositionText(e.data || '')
    // Á°Æ‰øùÂú®Êõ¥Êñ∞ÊúüÈó¥‰øùÊåÅÁªÑÂêàÁä∂ÊÄÅ
    setIsComposing(true)
    isComposingRef.current = true
  }

  const handleCompositionEnd = (e: React.CompositionEvent) => {
    console.log('üèÅ Composition ended - ËæìÂÖ•Ê≥ïÁªìÊùü', e.data)
    
    // Safari ÈúÄË¶ÅÈ¢ùÂ§ñÁöÑÂª∂ËøüÊù•Á°Æ‰øùÊ≠£Á°ÆÂ§ÑÁêÜ
    const delay = isSafari.current ? 150 : 50
    
    setTimeout(() => {
      setIsComposing(false)
      isComposingRef.current = false
      setCompositionText('')
      console.log('‚úÖ Composition state cleared')
    }, delay)
  }

  const copyMessage = (content: string) => {
    navigator.clipboard.writeText(content)
    toast.success('Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø')
  }  // Test API connection
  const testConnection = async () => {
    setApiStatus('testing')
    try {
      console.log('üîç Testing API connection...')
      
      // Test models endpoint
      const modelsResponse = await fetch(`${API_BASE_URL}/api/v1/models`, {
        headers: {
          'X-API-KEY': API_KEY,
          'accept': 'application/json'
        },
        signal: AbortSignal.timeout(10000)
      })
      
      console.log(`üìä Models test response: ${modelsResponse.status} ${modelsResponse.statusText}`)
      
      if (modelsResponse.ok) {
        // Test health endpoint instead of sending actual chat request
        const healthResponse = await fetch(`${API_BASE_URL}/health`, {
          headers: {
            'accept': 'application/json'
          },
          signal: AbortSignal.timeout(5000)
        })
        
        console.log(`‚ù§Ô∏è Health test response: ${healthResponse.status} ${healthResponse.statusText}`)
        
        if (healthResponse.ok) {
          setApiStatus('connected')
          console.log('‚úÖ API connection successful')
          toast.success('‚úÖ API ÈÄ£Êé•Ê≠£Â∏∏ÔºåÊâÄÊúâÁ´ØÈªûÂèØÁî®')
          fetchModels() // Refresh models
        } else {
          setApiStatus('connected') // Models work, health might not be implemented
          console.log('‚úÖ Models API works, health endpoint not available')
          toast.success('‚úÖ API ÈÄ£Êé•Ê≠£Â∏∏ÔºåÊ®°ÂûãÁ´ØÈªûÂèØÁî®')
          fetchModels() // Refresh models
        }
      } else {
        setApiStatus('disconnected')
        console.log('‚ùå Models API test failed')
        toast.error(`‚ùå Ê®°ÂûãAPIÊ∏¨Ë©¶Â§±Êïó: ${modelsResponse.status} ${modelsResponse.statusText}`)
      }
    } catch (error: any) {
      setApiStatus('disconnected')
      console.error('‚ùå Connection test failed:', error)
      
      if (error.name === 'TimeoutError' || error.name === 'AbortError') {
        toast.error('‚è∞ ÈÄ£Êé•Ê∏¨Ë©¶Ë∂ÖÊôÇÔºåË´ãÊ™¢Êü•Á∂≤Áµ°ÊàñÂæåÁ´ØÊúçÂãô')
      } else if (error.message.includes('fetch')) {
        toast.error('üåê Á∂≤Áµ°ÈÄ£Êé•Â§±ÊïóÔºåË´ãÁ¢∫‰øùÂæåÁ´ØÊúçÂãôÊ≠£Âú®ÈÅãË°å')
      } else {
        toast.error(`‚ùå ÈÄ£Êé•Ê∏¨Ë©¶Â§±Êïó: ${error.message}`)
      }
    }
  }

  const clearAllHistory = () => {
    setChatHistory([])
    setMessages([])
    setCurrentChatId('')
    localStorage.removeItem('chatHistory')
    toast.success('ÊâÄÊúâÂ∞çË©±Ê≠∑Âè≤Â∑≤Ê∏ÖÈô§')
  }  // API configuration
  const API_KEY = 'test_api_key'
  const REQUEST_TIMEOUT = 30000 // 30 seconds

  // Create abort controller for request cancellation
  const abortControllerRef = useRef<AbortController | null>(null)

  // ‰ºöËØùÂõæÁâáÊÅ¢Â§çÂáΩÊï∞
  const restoreSessionImages = async (sessionId: string, messages: Message[]): Promise<Message[]> => {
    try {
      console.log('üîÑ Restoring images for session:', sessionId)
      
      // Ëé∑Âèñ‰ºöËØùÁöÑÊâÄÊúâÂõæÁâá
      const response = await fetch(`${API_BASE_URL}/api/v1/session/${sessionId}/images`, {
        headers: {
          'X-API-KEY': API_KEY,
          'accept': 'application/json'
        }
      })

      if (response.ok) {
        const imageData = await response.json()
        console.log('üì∑ Found session images:', imageData.image_count, 'images')
        
        if (imageData.image_urls && imageData.image_urls.length > 0) {
          // ‰∏∫ÊØè‰∏™Ê∂àÊÅØÊ£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊ∑ªÂä†ÂõæÁâá
          const updatedMessages = messages.map((message, index) => {
            // Ê£ÄÊü•Ê∂àÊÅØÊòØÂê¶Â∑≤ÁªèÂåÖÂê´ÂõæÁâá
            const hasImage = message.content.includes('![') || message.content.includes('/api/v1/images/')
            
            // Â¶ÇÊûúÊòØÂä©ÊâãÊ∂àÊÅØ‰∏îÊ≤°ÊúâÂõæÁâáÔºåÂ∞ùËØïÂåπÈÖçÂØπÂ∫îÁöÑÂõæÁâá
            if (message.role === 'assistant' && !hasImage) {
              // ÂØªÊâæÂØπÂ∫îÁöÑÂõæÁâáÔºàÁÆÄÂåñÈÄªËæëÔºöÊåâÈ°∫Â∫èÂåπÈÖçÂä©ÊâãÊ∂àÊÅØÔºâ
              const assistantMessageIndex = messages.slice(0, index + 1)
                .filter(m => m.role === 'assistant').length - 1
              
              if (imageData.image_urls[assistantMessageIndex]) {
                console.log(`üñºÔ∏è Adding missing image to message ${message.id}`)
                return {
                  ...message,
                  content: message.content + `\n\n![ÁîüÊàêÁöÑÂúñÁâá](${imageData.image_urls[assistantMessageIndex]})`
                }
              }
            }
            
            return message
          })
          
          return updatedMessages
        }
      }
      
      return messages
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to restore session images:', error)
      return messages
    }
  }

  // Session management functions
  const createNewSession = async (): Promise<string> => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-KEY': API_KEY,
          'accept': 'application/json'
        },
        body: JSON.stringify({
          user_id: "test",
          title: "Êñ∞ÂØπËØù"
        })
      })

      if (!response.ok) {
        throw new Error(`ÂàõÂª∫‰ºöËØùÂ§±Ë¥•: ${response.status}`)
      }

      const data = await response.json()
      console.log('‚úÖ New session created:', data.session_id)
      return data.session_id
      
    } catch (error) {
      console.error('‚ùå Error creating session:', error)
      // Â¶ÇÊûúÂàõÂª∫‰ºöËØùÂ§±Ë¥•ÔºåÁîüÊàêÊú¨Âú∞session ID‰Ωú‰∏∫Â§áÁî®
      const fallbackId = Date.now().toString()
      console.log('üîÑ Using fallback session ID:', fallbackId)
      return fallbackId
    }
  }

  const loadChatSessions = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/v1/sessions/test?limit=20`, {
        headers: {
          'X-API-KEY': API_KEY,
          'accept': 'application/json'
        }
      })

      if (!response.ok) {
        throw new Error(`Ëé∑Âèñ‰ºöËØùÂàóË°®Â§±Ë¥•: ${response.status}`)
      }

      const data = await response.json()
        if (data.success && data.sessions) {
        // ËΩ¨Êç¢ÊúçÂä°Âô®‰ºöËØùÊ†ºÂºè‰∏∫ÂâçÁ´ØÊ†ºÂºè
        const sessions: ChatHistory[] = data.sessions.map((session: any) => ({
          id: session.session_id,
          title: session.title || "Êú™ÂëΩÂêçÂØπËØù",
          messages: session.messages || [],
          timestamp: session.updated_at || session.created_at
        }))
        
        setChatHistory(sessions)
        console.log('‚úÖ Loaded sessions from server:', sessions.length)
      } else {
        // Â¶ÇÊûúÊúçÂä°Âô®ËøîÂõûÁ©∫‰ºöËØùÂàóË°®ÔºåËÆæÁΩÆ‰∏∫Á©∫Êï∞ÁªÑ
        setChatHistory([])
        console.log('üì≠ No sessions found on server')
      }
        } catch (error) {
      console.warn('‚ö†Ô∏è Failed to load sessions from server:', error)
      // Â¶ÇÊûúÊúçÂä°Âô®Âä†ËΩΩÂ§±Ë¥•ÔºåÁõ¥Êé•ËÆæÁΩÆÁ©∫‰ºöËØùÂàóË°®ÔºåËÆ©Ëá™Âä®ÂàõÂª∫ÈÄªËæëÂ§ÑÁêÜ
      setChatHistory([])
      console.log('üì≠ Set empty session list due to server error')
    }
  }
  const loadSessionDetail = async (sessionId: string) => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/v1/sessions/test/${sessionId}`, {
        headers: {
          'X-API-KEY': API_KEY,
          'accept': 'application/json'
        }
      })

      if (!response.ok) {
        throw new Error(`Ëé∑Âèñ‰ºöËØùËØ¶ÊÉÖÂ§±Ë¥•: ${response.status}`)
      }

      const data = await response.json()
      
      if (data.success && data.session) {
        // Ëé∑ÂèñÂéüÂßãÊ∂àÊÅØÂàóË°®
        let sessionMessages = data.session.messages || []
        console.log('‚úÖ Loaded session detail:', sessionId, sessionMessages.length, 'messages')
          // Â∞ùËØïÊÅ¢Â§ç‰ºöËØùÂõæÁâá
        try {
          sessionMessages = await restoreSessionImages(sessionId, sessionMessages)
          console.log('üñºÔ∏è Images restored for session:', sessionId)
        } catch (imageError) {
          console.warn('‚ö†Ô∏è Failed to restore images for session:', sessionId, imageError)
        }        // Ëé∑Âèñ‰ºöËØùÂõæÁâáÂàóË°®‰ª•‰æøÂåπÈÖç attachment ÂºïÁî®
        let sessionImageUrls: string[] = []
        try {
          const imageResponse = await fetch(`${API_BASE_URL}/api/v1/session/${sessionId}/images`, {
            headers: {
              'X-API-KEY': API_KEY,
              'accept': 'application/json'
            }
          })
          if (imageResponse.ok) {
            const imageData = await imageResponse.json()
            sessionImageUrls = imageData.image_urls || []
            console.log('üì∑ Found session images for attachment matching:', sessionImageUrls.length)
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Failed to fetch session images for attachment matching:', error)
        }

        // ÈáçÂª∫ rawResponses Êï∞ÊçÆ
        const restoredRawResponses: {[messageId: string]: any} = {}
        let imageIndex = 0 // Áî®‰∫éË∑üË∏™ÂõæÁâáÁ¥¢ÂºïÔºåÊåâÈ°∫Â∫èÂàÜÈÖçÁªôÊúâÂõæÁâáÁöÑÂä©ÊâãÊ∂àÊÅØ
        
        sessionMessages.forEach((message: Message) => {
          if (message.role === 'assistant' && message.content) {
            // Ê£ÄÊü•Ê∂àÊÅØÂÜÖÂÆπÊòØÂê¶ÂåÖÂê´ÂõæÁâáÂºïÁî®
            if (message.content.includes('/api/v1/images/')) {
              // ‰ªéÊ∂àÊÅØÂÜÖÂÆπ‰∏≠ÊèêÂèñÂõæÁâáURL
              const imageUrlMatch = message.content.match(/!\[.*?\]\((\/api\/v1\/images\/[^)]+)\)/)
              if (imageUrlMatch) {
                restoredRawResponses[message.id] = {
                  image_data_uri: imageUrlMatch[1],
                  message: message.content.replace(/!\[.*?\]\([^)]+\)/, '').trim()
                }
                console.log('üîÑ Restored rawResponse for message:', message.id, imageUrlMatch[1])
                imageIndex++ // Â¢ûÂä†ÂõæÁâáÁ¥¢Âºï
              }
            }
            // Â§ÑÁêÜÂåÖÂê´ attachment ÂºïÁî®ÁöÑÊ∂àÊÅØ
            else if (message.content.includes('attachment')) {
              // Ê£ÄÊü•ÊòØÂê¶ÊúâÂØπÂ∫îÁöÑÂõæÁâáÈìæÊé•Ê®°Âºè
              const attachmentMatch = message.content.match(/!\[.*?\]\(attachment[^)]*\)/)
              if (attachmentMatch) {
                // Â∞ùËØï‰ªé‰ºöËØùÂõæÁâá‰∏≠ÊåâÈ°∫Â∫èÂåπÈÖçÂõæÁâá
                if (imageIndex < sessionImageUrls.length) {
                  const matchedImageUrl = sessionImageUrls[imageIndex]
                  restoredRawResponses[message.id] = {
                    image_data_uri: matchedImageUrl,
                    message: message.content.replace(/!\[.*?\]\(attachment[^)]*\)/, '').trim()
                  }
                  console.log('‚úÖ Matched attachment to image for message:', message.id, matchedImageUrl)
                  imageIndex++ // Â¢ûÂä†ÂõæÁâáÁ¥¢Âºï
                } else {
                  console.warn('‚ö†Ô∏è Found attachment reference but no available image for message:', message.id)
                  restoredRawResponses[message.id] = {
                    image_data_uri: '', // Ê≤°ÊúâÂèØÁî®ÂõæÁâá
                    message: message.content.replace(/!\[.*?\]\(attachment[^)]*\)/, '').trim()
                  }
                }
              }
            }
          }
        })
        setRawResponses(restoredRawResponses)
        console.log('üì¶ Restored rawResponses:', Object.keys(restoredRawResponses).length, 'entries')
        
        setMessages(sessionMessages)
        setCurrentChatId(sessionId)
        return true
      }
      
    } catch (error) {
      console.error('‚ùå Error loading session detail:', error)
      // Â¶ÇÊûúÂ§±Ë¥•ÔºåÂ∞ùËØï‰ªéÊú¨Âú∞ÂéÜÂè≤Âä†ËΩΩ
      const localChat = chatHistory.find(chat => chat.id === sessionId)
      if (localChat) {
        setMessages(localChat.messages)
        setCurrentChatId(sessionId)
        console.log('üîÑ Loaded from local cache:', sessionId)
        return true
      }
      return false
    }
  }

  const deleteSessionFromServer = async (sessionId: string) => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/v1/sessions/test/${sessionId}`, {
        method: 'DELETE',
        headers: {
          'X-API-KEY': API_KEY,
          'accept': 'application/json'
        }
      })

      if (!response.ok) {
        throw new Error(`Âà†Èô§‰ºöËØùÂ§±Ë¥•: ${response.status}`)
      }

      const data = await response.json()
      
      if (data.success) {
        console.log('‚úÖ Session deleted from server:', sessionId)
        // ÈáçÊñ∞Âä†ËΩΩ‰ºöËØùÂàóË°®
        await loadChatSessions()
        
        // Â¶ÇÊûúÂà†Èô§ÁöÑÊòØÂΩìÂâç‰ºöËØùÔºåÊ∏ÖÁ©∫Ê∂àÊÅØ
        if (currentChatId === sessionId) {
          setMessages([])
          setCurrentChatId('')
        }
        
        toast.success('ÂØπËØùÂ∑≤Âà†Èô§')
        return true
      }
      
    } catch (error) {
      console.error('‚ùå Error deleting session:', error)
      // Â¶ÇÊûúÊúçÂä°Âô®Âà†Èô§Â§±Ë¥•Ôºå‰ªçÁÑ∂‰ªéÊú¨Âú∞Âà†Èô§
      deleteChat(sessionId)
      return false
    }
  }

  const loadUserSessionsFromAPI = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/v1/sessions/test`, {
        headers: {
          'X-API-KEY': API_KEY,
        },
      })

      if (response.ok) {
        const result = await response.json()
        if (result.success && result.sessions) {
          const serverSessions: ChatHistory[] = result.sessions.map((session: any) => ({
            id: session.session_id,
            title: session.title,
            messages: session.messages?.map((msg: any) => ({
              id: msg.id || Date.now().toString(),
              role: msg.role,
              content: msg.content,
              timestamp: msg.timestamp || new Date().toISOString()
            })) || [],
            timestamp: session.updated_at || session.created_at
          }))
          
          // ÂêàÂπ∂ÊúçÂä°Âô®‰ºöËØùÂíåÊú¨Âú∞‰ºöËØùÔºåÈÅøÂÖçÈáçÂ§ç
          setChatHistory(prev => {
            const mergedSessions = [...serverSessions]
            
            // Ê∑ªÂä†‰∏çÂú®ÊúçÂä°Âô®‰∏äÁöÑÊú¨Âú∞‰ºöËØù
            prev.forEach(localChat => {
              if (!serverSessions.find(serverSession => serverSession.id === localChat.id)) {
                mergedSessions.push(localChat)
              }
            })
            
            // ÊåâÊó∂Èó¥Êà≥ÊéíÂ∫è
            return mergedSessions.sort((a, b) => 
              new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
            )
          })
          
          console.log('‚úÖ Sessions synced from server:', serverSessions.length)
          return true
        }
      }
      return false
    } catch (error) {
      console.error('‚ùå Error loading sessions:', error)
      return false
    }
  }  // ÊûÑÂª∫Â∏¶Êúâ‰ºöËØùIDÁöÑËØ∑Ê±Ç‰Ωì
  const buildRequestBodyWithSession = async (messages: Message[], sessionId?: string) => {
    // Â¶ÇÊûúÊ≤°ÊúâÊèê‰æõsessionIdÔºåÂàõÂª∫Êñ∞‰ºöËØù
    const finalSessionId = sessionId || await createNewSession()
    
    console.log('üîß Building request body - useAgent:', useAgent)
    
    if (useAgent) {
      // Agent API Ê†ºÂºè - ÈúÄË¶Å prompt Â≠óÊÆµ
      const lastMessage = messages[messages.length - 1]
      const agentBody = {
        prompt: lastMessage?.content || '',
        user_id: "test",
        model_name: selectedModel,
        session_id: finalSessionId,
        enable_memory: true,
        enable_reflection: true,
        enable_react_mode: true,
        enable_mcp: enableMcp,
        language: 'zh-CN'
      }
      console.log('ü§ñ Agent API request body:', agentBody)
      return agentBody
    } else {
      // Chat API Ê†ºÂºè - ÈúÄË¶Å messages Â≠óÊÆµ
      const chatBody = {
        messages: messages,
        model: selectedModel,
        user_id: "test",
        session_id: finalSessionId,
        tools: enableMcp ? undefined : [],
        enable_search: enableSearch,
        language: 'zh-CN',
        disable_history: disableHistory
      }
      console.log('üí¨ Chat API request body:', chatBody)
      return chatBody
    }
  }

  // Cancel ongoing request
  const cancelRequest = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
      setIsLoading(false)
      toast.info('Ë´ãÊ±ÇÂ∑≤ÂèñÊ∂à')
    }
  }

  // ‰ºöËØùÁÆ°ÁêÜAPIË∞ÉÁî®ÂáΩÊï∞
  const createNewSessionAPI = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-KEY': API_KEY,
        },
        body: JSON.stringify({
          user_id: "test",
          title: "Êñ∞ÂØπËØù"
        }),
      })

      if (response.ok) {
        const result = await response.json()
        console.log('‚úÖ Session created on server:', result.session_id)
        return result.session_id
      } else {
        console.error('‚ùå Failed to create session on server')
        return null
      }
    } catch (error) {
      console.error('‚ùå Error creating session:', error)
      return null
    }
  }

  const loadSessionFromAPI = async (sessionId: string) => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/v1/sessions/test/${sessionId}`, {
        headers: {
          'X-API-KEY': API_KEY,
        },
      })

      if (response.ok) {
        const result = await response.json()
        if (result.success && result.session) {
          const session = result.session
          const sessionMessages: Message[] = session.messages.map((msg: any) => ({
            id: msg.id || Date.now().toString(),
            role: msg.role,
            content: msg.content,
            timestamp: msg.timestamp || new Date().toISOString()
          }))
          
          setMessages(sessionMessages)
          setCurrentChatId(sessionId)
          
          // Êõ¥Êñ∞Êú¨Âú∞ÁºìÂ≠ò
          const chatExists = chatHistory.find(chat => chat.id === sessionId)
          if (!chatExists) {
            const newChat: ChatHistory = {
              id: sessionId,
              title: session.title || "Âä†ËΩΩÁöÑÂØπËØù",
              messages: sessionMessages,
              timestamp: session.updated_at || new Date().toISOString()
            }
            setChatHistory(prev => [newChat, ...prev])
          }
          
          console.log('‚úÖ Session loaded from server:', sessionId)
          return true
        }
      }
      return false
    } catch (error) {
      console.error('‚ùå Error loading session:', error)
      return false
    }  }

  // Enhanced API request function with retry logic
  const makeApiRequest = async (endpoint: string, body: any, retries = 2): Promise<any> => {
    // Cancel previous request if still pending
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
    }

    // Create new abort controller
    abortControllerRef.current = new AbortController()
    const timeoutId = setTimeout(() => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
    }, REQUEST_TIMEOUT)

    try {
      console.log(`üöÄ Making API request to: ${endpoint}`)
      console.log(`üîÑ Attempt: ${3 - retries}/3`)
      console.log('üì¶ Request body:', JSON.stringify(body, null, 2))

      // Validate request body to prevent invalid HTTP requests
      if (!body || typeof body !== 'object') {
        throw new Error('Invalid request body: must be a valid object')
      }

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-KEY': API_KEY,
          'accept': 'application/json'
        },
        body: JSON.stringify(body),
        signal: abortControllerRef.current.signal
      })

      clearTimeout(timeoutId)

      if (!response.ok) {
        const errorText = await response.text()
        console.error(`‚ùå API Error Response (${response.status}):`, errorText)
        throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} - ${errorText}`)
      }

      const data = await response.json()
      console.log('‚úÖ API Response received:', data)
      return data

    } catch (error: any) {
      clearTimeout(timeoutId)
      
      if (error.name === 'AbortError') {
        console.log('üõë Request was cancelled')
        throw new Error('ËØ∑Ê±ÇÂ∑≤ÂèñÊ∂à')
      }

      console.error(`‚ùå API request failed (attempt ${3 - retries}/3):`, error)

      if (retries > 0 && !error.message.includes('please try again later')) {
        console.log(`üîÑ Retrying in ${(3 - retries) * 1000}ms...`)
        await new Promise(resolve => setTimeout(resolve, (3 - retries) * 1000))
        return makeApiRequest(endpoint, body, retries - 1)
      }      throw error
    }
  }

  // Parse API response based on mode
  const parseApiResponse = (data: any, isAgentMode: boolean): string => {
    try {
      console.log('üîç Parsing API response:', JSON.stringify(data, null, 2))
      
      let message = ''
      
      if (isAgentMode) {
        // Agent mode response parsing - Â§ÑÁêÜÂµåÂ•óÁªìÊûÑ
        console.log('ü§ñ Parsing Agent mode response')
        
        if (data.response && data.response.choices && data.response.choices[0] && data.response.choices[0].message) {
          // Ê†áÂáÜÁöÑ Agent ÂìçÂ∫îÊ†ºÂºèÔºödata.response.choices[0].message.content
          message = data.response.choices[0].message.content
          console.log('‚úÖ Found message in data.response.choices[0].message.content')
          
          // Ê∑ªÂä† Agent Ê®°ÂºèÁöÑÈ¢ùÂ§ñ‰ø°ÊÅØÊó•Âøó
          const agentInfo = {
            success: data.success,
            interaction_id: data.interaction_id,
            execution_time: data.execution_time,
            steps_taken: data.steps_taken,
            execution_trace: data.execution_trace?.length || 0,
            reasoning_steps: data.reasoning_steps?.length || 0
          };
          console.log('ü§ñ Agent response metadata:', agentInfo);
          
        } else if (data.response && typeof data.response === 'string') {
          // ÁÆÄÂçïÁöÑÂìçÂ∫îÂ≠óÁ¨¶‰∏≤
          message = data.response
          console.log('‚úÖ Found message in data.response (string)')
        } else if (data.message) {
          // Â§áÁî®ÔºöÁõ¥Êé•ÁöÑ message Â≠óÊÆµ
          message = data.message
          console.log('‚úÖ Found message in data.message')
        } else {
          console.warn('‚ö†Ô∏è Agent response structure not recognized, trying fallback methods')
          // Â∞ùËØïÂÖ∂‰ªñÂèØËÉΩÁöÑË∑ØÂæÑ
          if (data.choices && data.choices[0] && data.choices[0].message) {
            message = data.choices[0].message.content
          }
        }
      } else {
        // Chat mode response parsing
        console.log('üí¨ Parsing Chat mode response')
        
        if (data.message) {
          message = data.message
        } else if (data.choices && data.choices[0] && data.choices[0].message) {
          message = data.choices[0].message.content
        } else if (data.response) {
          message = data.response
        }
      }
        
      console.log('üìù Extracted message:', message)
      
      // Á°Æ‰øù message ÊòØÂ≠óÁ¨¶‰∏≤Á±ªÂûã
      if (typeof message !== 'string') {
        console.warn('‚ö†Ô∏è Non-string message detected:', typeof message, message)
        message = String(message || '')
      }

      // Áªü‰∏ÄÁöÑÂõæÁâáÂ§ÑÁêÜÈÄªËæë
      const imageDataUri = isAgentMode ? 
        (data.generated_image || data.image_data_uri || (data.response && data.response.image_data_uri)) :
        data.image_data_uri;
      
      if (imageDataUri) {
        console.log('üîç Processing image data from API response')
        message = processImageInMessage(message, imageDataUri);
      }
      
      // Ê£ÄÊü•ÊòØÂê¶ÊúâÊú¨Âú∞ÂõæÁâáURL
      if (data.local_image_url && !imageDataUri) {
        console.log('ÔøΩ Found local image URL:', data.local_image_url)
        const localImageUrl = `${API_BASE_URL}${data.local_image_url}`
        
        if (message) {
          message += `\n\n![ÁîüÊàêÁöÑÂõæÁâá](${localImageUrl})`
        } else {
          message = `![ÁîüÊàêÁöÑÂõæÁâá](${localImageUrl})`
        }
      }
        
      if (message) {
        return String(message) // Á°Æ‰øùËøîÂõûÂ≠óÁ¨¶‰∏≤
      }
      
      console.warn('‚ö†Ô∏è Unexpected response structure:', data)
      return JSON.stringify(data, null, 2) || 'Êî∂Âà∞‰∫ÜÊÑèÂ§ñÁöÑÂìçÂ∫îÊ†ºÂºè'
    } catch (error) {
      console.error('‚ùå Error parsing API response:', error)
      return 'Ëß£ÊûêÂìçÂ∫îÊó∂Âá∫Èîô'
    }
  }

  // ÊäΩÂèñÂõæÁâáÂ§ÑÁêÜÈÄªËæëÂà∞Áã¨Á´ãÂáΩÊï∞
  const processImageInMessage = (message: string, imageDataUri: string): string => {
    // Â¶ÇÊûúimage_data_uriÊòØMongoDB URLÊ†ºÂºèÔºàÂ¶Ç /api/v1/images/{id}Ôºâ
    if (imageDataUri.startsWith('/api/v1/images/')) {
      console.log('üìä Detected MongoDB image URL:', imageDataUri)
      
      // Ê£ÄÊü•Ê∂àÊÅØ‰∏≠ÊòØÂê¶Â∑≤ÂåÖÂê´ÂõæÁâá
      if (!message.includes('![') && !message.includes(imageDataUri)) {
        console.log('üñºÔ∏è Adding MongoDB image URL to message')
        const imageMarkdown = `\n\n![ÁîüÊàêÁöÑÂúñÁâá](${imageDataUri})`
        message = (message || '') + imageMarkdown
        console.log('‚úÖ Added MongoDB image URL to message')
      }
    }
    // Â§ÑÁêÜ‰º†ÁªüÁöÑdata URIÊ†ºÂºè
    else if (imageDataUri.startsWith('data:image/')) {
      console.log('üì∑ Processing data URI image, length:', imageDataUri.length)
      
      // Ê£ÄÊü•Ê∂àÊÅØ‰∏≠ÊòØÂê¶ÂåÖÂê´ attachment ÂºïÁî®ÈúÄË¶ÅÊõøÊç¢
      if (message.includes('attachment://') || message.includes('attachment:/') || 
          message.includes('(attachment') || (message.includes('![') && message.includes('attachment'))) {
        
        console.log('üîÑ Found attachment reference in message, replacing with actual image data')
        
        // ÊõøÊç¢attachmentÂºïÁî®
        const attachmentRegex = /!\[([^\]]*)\]\((attachment:[\/]{0,2}[^)]*)\)/g
        const originalMessage = message
        
        if (message.match(attachmentRegex)) {
          message = message.replace(attachmentRegex, (match, p1) => {
            console.log(`üîß Replacing "${match}" with image data URI`)
            return `![${p1 || 'ÁîüÊàêÁöÑÂúñÁâá'}](${imageDataUri})`
          })
        } else {
          // Áõ¥Êé•ÊõøÊç¢ÂåÖÂê´attachmentÁöÑË°å
          const lines = message.split('\n')
          message = lines.map(line => {
            if (line.includes('attachment') && line.includes('![')) {
              return `![ÁîüÊàêÁöÑÂúñÁâá](${imageDataUri})`
            }
            return line
          }).join('\n')
        }
        
        // Â¶ÇÊûúÊõøÊç¢Â§±Ë¥•ÔºåÁõ¥Êé•Ê∑ªÂä†ÂõæÁâá
        if (message === originalMessage || !message.includes(imageDataUri.substring(0, 20))) {
          console.log('‚ö†Ô∏è Replacement failed, appending image directly')
          message += `\n\n![ÁîüÊàêÁöÑÂúñÁâá](${imageDataUri})`
        }
      }
      // Â¶ÇÊûúÊ∂àÊÅØ‰∏≠Ê≤°ÊúâÂõæÁâáÔºåÊ∑ªÂä†ÂõæÁâá
      else if (!message.includes(imageDataUri.substring(0, 20)) && 
               (!message.includes('![') || !message.includes('ÁîüÊàêÁöÑÂúñÁâá'))) {
        console.log('üñºÔ∏è Adding missing image data to message')
        const imageMarkdown = `\n\n![ÁîüÊàêÁöÑÂúñÁâá](${imageDataUri})`
        message = (message || '') + imageMarkdown
        console.log('‚úÖ Added image data URI to message')
      }
    }
    
    return message;
  }

  // Enhanced local cache management
  const CACHE_KEY = 'chatHistory'
  const CACHE_METADATA_KEY = 'chatHistoryMetadata'
  const CACHE_EXPIRY = 24 * 60 * 60 * 1000 // 24 hours

  // Cache metadata interface
  interface CacheMetadata {
    lastSync: number
    version: string
    userId: string
  }

  // Save to cache with metadata
  const saveChatHistoryToCache = (sessions: ChatHistory[]) => {
    try {
      const metadata: CacheMetadata = {
        lastSync: Date.now(),
        version: '1.0',
        userId: 'test'
      }
      
      localStorage.setItem(CACHE_KEY, JSON.stringify(sessions))
      localStorage.setItem(CACHE_METADATA_KEY, JSON.stringify(metadata))
      console.log('üíæ Chat history saved to cache:', sessions.length, 'sessions')
    } catch (error) {
      console.error('‚ùå Failed to save to cache:', error)
    }
  }

  // Load from cache with validation
  const loadChatHistoryFromCache = (): ChatHistory[] => {
    try {
      const cachedData = localStorage.getItem(CACHE_KEY)
      const metadataString = localStorage.getItem(CACHE_METADATA_KEY)
      
      if (!cachedData || !metadataString) {
        console.log('üì≠ No cached data found')
        return []
      }

      const metadata: CacheMetadata = JSON.parse(metadataString)
      
      // Check if cache is expired
      if (Date.now() - metadata.lastSync > CACHE_EXPIRY) {
        console.log('‚è∞ Cache expired, clearing')
        clearCache()
        return []
      }

      const sessions: ChatHistory[] = JSON.parse(cachedData)
      console.log('üìÅ Loaded from cache:', sessions.length, 'sessions')
      return sessions
      
    } catch (error) {
      console.error('‚ùå Failed to load from cache:', error)
      clearCache()
      return []
    }
  }

  // Clear cache
  const clearCache = () => {
    localStorage.removeItem(CACHE_KEY)
    localStorage.removeItem(CACHE_METADATA_KEY)
    console.log('üóëÔ∏è Cache cleared')
  }

  // Smart sync strategy
  const syncChatHistory = async (): Promise<boolean> => {
    try {
      console.log('üîÑ Starting smart sync...')
      
      // Load cached data first
      const cachedSessions = loadChatHistoryFromCache()
      
      // Try to load from server
      const serverLoaded = await loadUserSessionsFromAPI()
      
      if (serverLoaded) {
        // Server data loaded successfully
        console.log('‚úÖ Synced from server')
        return true
      } else {
        // Server failed, use cached data
        if (cachedSessions.length > 0) {
          setChatHistory(cachedSessions)
          console.log('üîÑ Using cached data as fallback')
          return true
        } else {
          console.log('üì≠ No server data and no cache')
          return false
        }
      }
    } catch (error) {
      console.error('‚ùå Sync failed:', error)
      
      // Fallback to cache
      const cachedSessions = loadChatHistoryFromCache()
      if (cachedSessions.length > 0) {
        setChatHistory(cachedSessions)
        return true
      }
      return false
    }
  }

  // Auto-save to cache whenever chatHistory changes
  useEffect(() => {
    if (chatHistory.length > 0) {
      saveChatHistoryToCache(chatHistory)
    }
  }, [chatHistory])

  // Enhanced load function with smart caching
  const loadChatHistoryEnhanced = () => {
    syncChatHistory()
  }

  // ÂàùÂßãÂåñÊó∂Ê£ÄÊü•Âπ∂ÊÅ¢Â§çÊâÄÊúâ‰ºöËØùÁöÑÂõæÁâá
  const initializeSessionImages = async () => {
    try {
      console.log('üîÑ Initializing session images...')
      
      // Ê£ÄÊü•ÂΩìÂâç‰ºöËØùÊòØÂê¶ÈúÄË¶ÅÂõæÁâáÊÅ¢Â§ç
      if (currentChatId && messages.length > 0) {
        const hasAnyImages = messages.some(msg => 
          msg.content.includes('![') || msg.content.includes('/api/v1/images/')
        )
        
        // Â¶ÇÊûúÊ≤°ÊúâÂõæÁâá‰ΩÜÊúâÂä©ÊâãÊ∂àÊÅØÔºåÂ∞ùËØïÊÅ¢Â§çÂõæÁâá
        if (!hasAnyImages && messages.some(msg => msg.role === 'assistant')) {
          console.log('üñºÔ∏è Current session may be missing images, attempting restore...')
          const restoredMessages = await restoreSessionImages(currentChatId, messages)
          if (restoredMessages.length > 0 && restoredMessages !== messages) {
            setMessages(restoredMessages)
            console.log('‚úÖ Session images restored successfully')
          }
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to initialize session images:', error)
    }
  }

  // Âú®ÁªÑ‰ª∂ÊåÇËΩΩÊó∂ÊâßË°åÂõæÁâáÂàùÂßãÂåñ
  useEffect(() => {
    if (currentChatId && messages.length > 0) {
      initializeSessionImages()
    }
  }, [currentChatId]) // Âè™Âú®‰ºöËØùIDÂèòÂåñÊó∂Ëß¶Âèë

  // Update chat history when messages change
  useEffect(() => {
    if (currentChatId && messages.length > 0) {
      setChatHistory(prev => 
        prev.map(chat => 
          chat.id === currentChatId 
            ? { ...chat, messages: messages, timestamp: new Date().toISOString() }
            : chat
        )
      )
    }
  }, [messages, currentChatId])

  return (
    <div className="flex h-screen bg-background">
      {/* Modern Sidebar with Morphic-style design */}
      <div className={cn(
        "transition-all duration-300 ease-linear bg-muted/30 border-r border-border flex flex-col",
        sidebarOpen ? "w-64" : "w-0 overflow-hidden"
      )}>        {/* Sidebar Header */}
        <div className="flex items-center justify-between p-4 border-b border-border">
          <div className="flex items-center gap-2">
            <div className="w-6 h-6 bg-primary rounded-md flex items-center justify-center">
              <Bot className="w-4 h-4 text-primary-foreground" />
            </div>
            <span className="font-semibold text-sm">AI Assistant</span>
          </div>
          <Button
            variant="ghost"
            size="icon"
            onClick={() => setSidebarOpen(false)}
            className="h-6 w-6"
          >
            <PanelLeft className="w-4 h-4" />
          </Button>
        </div>

        {/* API Status Indicator */}
        <div className="px-4 py-2 border-b border-border">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <div className={cn(
                "w-2 h-2 rounded-full",
                apiStatus === 'connected' && "bg-green-500",
                apiStatus === 'disconnected' && "bg-red-500",
                apiStatus === 'testing' && "bg-yellow-500 animate-pulse"
              )} />
              <span className="text-xs text-muted-foreground">
                {apiStatus === 'connected' && 'Â∑≤ÈÄ£Êé•'}
                {apiStatus === 'disconnected' && 'Êú™ÈÄ£Êé•'}
                {apiStatus === 'testing' && 'Ê∏¨Ë©¶‰∏≠...'}
              </span>
            </div>
            <Button
              variant="ghost"
              size="sm"
              onClick={testConnection}
              disabled={apiStatus === 'testing'}
              className="h-6 px-2 text-xs"
            >
              Ê∏¨Ë©¶
            </Button>
          </div>
        </div>

        {/* New Chat Button */}
        <div className="p-3">
          <Button
            onClick={createNewChat}
            className="w-full justify-start gap-2 bg-background hover:bg-accent text-foreground border border-input rounded-lg h-10 font-normal shadow-sm"
            variant="outline"
          >
            <Plus className="w-4 h-4" />
            Êñ∞ÂØπËØù
          </Button>
        </div>
        
        {/* Chat History */}
        <div className="flex-1 overflow-y-auto px-3">
          <div className="text-xs text-muted-foreground mb-3 px-2">ÊúÄËøëÂØπËØù</div>
          <div className="space-y-1">
            {chatHistory.map((chat) => (
              <div
                key={chat.id}
                className={cn(
                  "group relative flex items-center justify-between p-2 rounded-lg cursor-pointer transition-colors text-sm hover:bg-accent",
                  currentChatId === chat.id && "bg-accent"
                )}
                onClick={() => loadChat(chat)}
              >
                <div className="flex-1 min-w-0">
                  <div className="truncate font-medium text-foreground">{chat.title}</div>
                  <div className="text-xs text-muted-foreground">
                    {new Date(chat.timestamp).toLocaleString('zh-CN', {
                      month: '2-digit',
                      day: '2-digit',
                      hour: '2-digit',
                      minute: '2-digit'
                    })}
                  </div>
                </div>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={(e) => {
                    e.stopPropagation()
                    deleteChat(chat.id)
                  }}
                  className="opacity-0 group-hover:opacity-100 h-6 w-6 shrink-0"
                >
                  <Trash2 className="w-3 h-3" />
                </Button>
              </div>
            ))}
          </div>
        </div>

        {/* Settings Panel */}
        <div className="p-3 border-t border-border">
          <div className="space-y-4">
            {/* Model Selection */}
            <div className="space-y-2">
              <Label className="text-xs text-muted-foreground">Ê®°Âûã</Label>
              <Select value={selectedModel} onValueChange={setSelectedModel}>
                <SelectTrigger className="h-8 text-xs bg-background border-input">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {models.map((model) => (
                    <SelectItem key={model.id} value={model.id} className="text-xs">
                      {model.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            
            {/* Settings Toggles */}
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <Label className="text-xs text-muted-foreground">AgentÊ®°Âºè</Label>
                <Switch
                  checked={useAgent}
                  onCheckedChange={setUseAgent}
                  className="scale-75"
                />
              </div>
              
              <div className="flex items-center justify-between">
                <Label className="text-xs text-muted-foreground">ÊêúÁ¥¢ÂäüËÉΩ</Label>
                <Switch
                  checked={enableSearch}
                  onCheckedChange={setEnableSearch}
                  className="scale-75"
                />
              </div>
              
              <div className="flex items-center justify-between">
                <Label className="text-xs text-muted-foreground">MCPÂ∑•ÂÖ∑</Label>
                <Switch
                  checked={enableMcp}
                  onCheckedChange={setEnableMcp}
                  className="scale-75"
                />
              </div>

              {useAgent && (
                <>
                  <div className="flex items-center justify-between">
                    <Label className="text-xs text-muted-foreground">ËÆ∞ÂøÜÂäüËÉΩ</Label>
                    <Switch
                      checked={enableMemory}
                      onCheckedChange={setEnableMemory}
                      className="scale-75"
                    />
                  </div>
                  
                  <div className="flex items-center justify-between">
                    <Label className="text-xs text-muted-foreground">ÂèçÊÄùÊ®°Âºè</Label>
                    <Switch
                      checked={enableReflection}
                      onCheckedChange={setEnableReflection}
                      className="scale-75"
                    />
                  </div>
                  
                  <div className="flex items-center justify-between">
                    <Label className="text-xs text-muted-foreground">ReactÊ®°Âºè</Label>
                    <Switch
                      checked={enableReactMode}
                      onCheckedChange={setEnableReactMode}
                      className="scale-75"
                    />
                  </div>
                </>
              )}

              {!useAgent && (
                <div className="flex items-center justify-between">
                  <Label className="text-xs text-muted-foreground">Á¶ÅÁî®ÂéÜÂè≤</Label>
                  <Switch
                    checked={disableHistory}
                    onCheckedChange={setDisableHistory}
                    className="scale-75"
                  />
                </div>              )}
            </div>
              {/* Action Buttons */}
            <div className="pt-3 border-t border-border space-y-2">              <Button
                variant="outline"
                size="sm"
                onClick={clearAllHistory}
                className="w-full h-8 text-xs justify-start gap-2"
              >
                <Trash2 className="w-3 h-3" />
                Ê∏ÖÈô§ÊâÄÊúâÂ∞çË©±
              </Button>
              
              <Button
                variant="outline"
                size="sm"
                onClick={() => {
                  setRawResponses({})
                  setExpandedJson({})
                  toast.success('JSONÁºìÂ≠òÂ∑≤Ê∏ÖÁêÜ')
                }}
                className="w-full h-8 text-xs justify-start gap-2"
              >
                <Code className="w-3 h-3" />
                Ê∏ÖÁêÜJSONÁºìÂ≠ò ({Object.keys(rawResponses).length})
              </Button>
              
              {/* Debug Info */}
              <details className="text-xs">
                <summary className="cursor-pointer text-muted-foreground hover:text-foreground">
                  Ë™øË©¶‰ø°ÊÅØ
                </summary>
                <div className="mt-2 p-2 bg-muted/50 rounded text-xs space-y-1">                  
                <div><strong>APIÂú∞ÂùÄ:</strong> {API_BASE_URL}</div>
                  <div><strong>APIÂØÜÈë∞:</strong> {API_KEY}</div>
                  <div><strong>Áï∂ÂâçÊ®°Âûã:</strong> {selectedModel}</div>
                  <div><strong>ÂèØÁî®Ê®°Âûã:</strong> {models.length}ÂÄã</div>
                  <div><strong>ÈÄ£Êé•ÁãÄÊÖã:</strong> {apiStatus}</div>
                  <div><strong>Ê®°Âºè:</strong> {useAgent ? 'Agent' : 'Chat'}</div>
                  <div><strong>JSONÁºìÂ≠ò:</strong> {Object.keys(rawResponses).length}Êù°</div>
                  <div><strong>ÂäüËÉΩÁãÄÊÖã:</strong></div>
                  <div className="ml-2">
                    ‚Ä¢ ÊêúÁ¥¢: {enableSearch ? '‚úì' : '‚úó'}<br/>
                    ‚Ä¢ MCP: {enableMcp ? '‚úì' : '‚úó'}<br/>
                    {useAgent && (
                      <>
                        ‚Ä¢ Ë®òÊÜ∂: {enableMemory ? '‚úì' : '‚úó'}<br/>
                        ‚Ä¢ ÂèçÊÄù: {enableReflection ? '‚úì' : '‚úó'}<br/>
                        ‚Ä¢ React: {enableReactMode ? '‚úì' : '‚úó'}
                      </>
                    )}
                    {!useAgent && (
                      <>‚Ä¢ Á¶ÅÁî®Ê≠∑Âè≤: {disableHistory ? '‚úì' : '‚úó'}</>
                    )}
                  </div>
                </div>
              </details>
            </div>
          </div>
        </div>
      </div>{/* Main Chat Area */}
      <div className="flex-1 flex flex-col min-w-0">
        {/* Header */}
        <div className="h-14 border-b border-border flex items-center justify-between px-4 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
          <div className="flex items-center gap-3">
            {!sidebarOpen && (
              <Button
                variant="ghost"
                size="icon"
                onClick={() => setSidebarOpen(true)}
                className="h-8 w-8"
              >
                <PanelLeft className="w-4 h-4" />              </Button>
            )}
            
            <div className="flex items-center gap-2">
              <h1 className="text-lg font-semibold">AI Assistant</h1>              <div className="flex items-center gap-1 text-xs text-muted-foreground">
                <div className={cn(
                  "w-2 h-2 rounded-full",
                  apiStatus === 'connected' && "bg-green-500",
                  apiStatus === 'disconnected' && "bg-red-500",
                  apiStatus === 'testing' && "bg-yellow-500 animate-pulse"
                )} />
                <span>
                  {apiStatus === 'connected' && 'Â∑≤ÈÄ£Êé•'}
                  {apiStatus === 'disconnected' && 'Êú™ÈÄ£Êé•'}
                  {apiStatus === 'testing' && 'ÈÄ£Êé•‰∏≠...'}
                </span>
              </div>
            </div>
          </div>
          
          <div className="flex items-center gap-2">
            <ThemeToggle />
          </div>
        </div>

        {/* Messages Area */}
        <div 
          ref={scrollContainerRef}
          className="flex-1 overflow-y-auto"
        >
          {messages.length === 0 ? (
            <div className="h-full flex items-center justify-center">
              <div className="text-center max-w-md px-4">
                <div className="w-16 h-16 bg-primary rounded-2xl mx-auto mb-6 flex items-center justify-center">
                  <Bot className="w-8 h-8 text-primary-foreground" />
                </div>
                <h2 className="text-2xl font-semibold mb-3">
                  ‰Ω†Â•ΩÔºÅÊàëÊòØ‰Ω†ÁöÑAIÂä©Êâã
                </h2>
                <p className="text-muted-foreground text-lg leading-relaxed">
                  ÊàëÂèØ‰ª•ÂõûÁ≠îÈóÆÈ¢ò„ÄÅÂçèÂä©Â∑•‰Ωú„ÄÅËøõË°åÂàõ‰ΩúÁ≠â„ÄÇÊúâ‰ªÄ‰πàÂèØ‰ª•Â∏ÆÂä©‰Ω†ÁöÑÂêóÔºü
                </p>
              </div>
            </div>
          ) : (
            <div className="max-w-4xl mx-auto px-4">              {messages.map((message) => (
                <MessageErrorBoundary key={message.id} messageId={message.id}>
                  <div className="group py-6 border-b border-border/50 last:border-0">
                  <div className="flex gap-4">
                    {/* Avatar */}
                    <div className="flex-shrink-0">
                      {message.role === 'user' ? (
                        <div className="w-8 h-8 bg-primary rounded-full flex items-center justify-center">
                          <User className="w-4 h-4 text-primary-foreground" />
                        </div>
                      ) : (
                        <div className="w-8 h-8 bg-muted rounded-full flex items-center justify-center border">
                          <Bot className="w-4 h-4 text-muted-foreground" />
                        </div>
                      )}
                    </div>
                    
                    {/* Message Content */}
                    <div className="flex-1 min-w-0 space-y-2">
                      <div className="text-sm font-medium text-foreground">
                        {message.role === 'user' ? '‰Ω†' : 'AIÂä©Êâã'}                      </div>                      <div className="prose prose-sm max-w-none dark:prose-invert">                        <ReactMarkdown 
                          remarkPlugins={[remarkGfm]}
                          rehypePlugins={[rehypeRaw]}                          urlTransform={(url) => {
                            // Â§ÑÁêÜ‰∏çÂêåÁ±ªÂûãÁöÑURL
                            console.log('üîÑ Processing URL in ReactMarkdown:', url.substring(0, 50))
                            
                            // Â¶ÇÊûúURLÊòØ attachment Áõ∏ÂÖ≥ÁöÑÔºå‰ΩøÁî®ÁâπÊÆäÂ§ÑÁêÜ
                            if (url.startsWith('attachment://') || url.startsWith('attachment:/') || url === 'attachment' || url === 'attachment_url' || url.includes('attachment')) {
                              console.log('üîÑ Transforming attachment URL in ReactMarkdown:', url, 'for message:', message.id)
                              
                              // Â∞ùËØïÊü•ÊâæÊ∂àÊÅØ ID ÂØπÂ∫îÁöÑÂéüÂßãÂìçÂ∫î
                              if (rawResponses[message.id]?.image_data_uri) {
                                const imageUri = rawResponses[message.id].image_data_uri
                                console.log('‚úÖ Found image data for attachment:', imageUri.substring(0, 50))
                                
                                // Â¶ÇÊûúÂ∑≤ÁªèÊòØÂÆåÊï¥ÁöÑURLÔºåÁõ¥Êé•ËøîÂõû
                                if (imageUri.startsWith('http://') || imageUri.startsWith('https://')) {
                                  return imageUri
                                }
                                // Â¶ÇÊûúÊòØÁõ∏ÂØπË∑ØÂæÑÔºåËΩ¨Êç¢‰∏∫ÂÆåÊï¥URL
                                else if (imageUri.startsWith('/api/v1/images/')) {
                                  return `${API_BASE_URL}${imageUri}`
                                }
                                // Â¶ÇÊûúÊòØdata URIÔºåÁõ¥Êé•ËøîÂõû
                                else if (imageUri.startsWith('data:')) {
                                  return imageUri
                                }
                                else {
                                  return imageUri
                                }
                              } else {
                                console.warn('‚ö†Ô∏è No image data URI found for message:', message.id)
                                console.warn('üì¶ Available rawResponses keys:', Object.keys(rawResponses))
                                console.warn('üîç Message content preview:', message.content?.substring(0, 100))
                                // ËøîÂõûÁ©∫Â≠óÁ¨¶‰∏≤ËÄå‰∏çÊòØÁ©∫ÁöÑ attachmentÔºåËøôÊ†∑ÂèØ‰ª•ÈÅøÂÖçÊòæÁ§∫Á†¥ÊçüÁöÑÂõæÁâá
                                return ''
                              }
                            }
                            
                            // Â¶ÇÊûúÊòØAPIÂõæÁâáURLÔºåËΩ¨Êç¢‰∏∫ÂÆåÊï¥URL
                            if (url.startsWith('/api/v1/images/')) {
                              console.log('üîÑ Converting API image URL to full URL:', url)
                              return `${API_BASE_URL}${url}`
                            }
                            
                            return url
                          }}
                          components={{                            img: (props) => {
                              console.log('üñºÔ∏è ReactMarkdown img props:', 
                                props.src 
                                  ? (typeof props.src === 'string' 
                                      ? props.src.substring(0, 50) + '...' 
                                      : '[non-string src]'
                                    ) 
                                  : '[empty]'
                              )
                              return <ImageComponent {...props} />
                            },
                            p: ({ children }) => {
                              // Ê£ÄÊü•children‰∏≠ÊòØÂê¶ÂåÖÂê´ÂõæÁâáÔºåÂ¶ÇÊûúÊúâÂàô‰ΩøÁî®divËÄå‰∏çÊòØp
                              const hasImage = React.Children.toArray(children).some(child => 
                                React.isValidElement(child) && child.type === 'img'
                              )
                              
                              if (hasImage) {
                                return (
                                  <div className="text-foreground leading-relaxed whitespace-pre-wrap mb-2">
                                    {children}
                                  </div>
                                )
                              }
                              
                              return (
                                <p className="text-foreground leading-relaxed whitespace-pre-wrap mb-2">
                                  {children}
                                </p>
                              )
                            },
                            code: ({ children, className, ...props }) => {
                              const isInline = !className
                              return isInline ? (
                                <code className="bg-muted px-1 py-0.5 rounded text-sm font-mono" {...props}>
                                  {children}
                                </code>
                              ) : (
                                <code className="block bg-muted p-3 rounded-lg text-sm font-mono overflow-x-auto" {...props}>
                                  {children}
                                </code>
                              )
                            }
                          }}                        >
                          {typeof message.content === 'string' ? message.content : JSON.stringify(message.content)}
                        </ReactMarkdown>
                      </div>
                        {/* Message Actions */}
                      <div className="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => copyMessage(message.content)}
                          className="h-7 px-2 text-xs"
                        >
                          <Copy className="w-3 h-3 mr-1" />
                          Â§çÂà∂
                        </Button>
                        {/* JSONÂ±ïÂºÄÊåâÈíÆ - Âè™ÂØπAIÂä©ÊâãÊ∂àÊÅØÊòæÁ§∫ */}
                        {message.role === 'assistant' && rawResponses[message.id] && (
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => setExpandedJson(prev => ({
                              ...prev,
                              [message.id]: !prev[message.id]
                            }))}
                            className="h-7 px-2 text-xs"
                          >
                            <Code className="w-3 h-3 mr-1" />
                            {expandedJson[message.id] ? 'ÈöêËóèJSON' : 'ÊòæÁ§∫JSON'}
                          </Button>
                        )}
                        <span className="text-xs text-muted-foreground">
                          {new Date(message.timestamp).toLocaleTimeString('zh-CN', {
                            hour: '2-digit',
                            minute: '2-digit'
                          })}
                        </span>
                      </div>
                        {/* ÂéüÂßãJSONÂìçÂ∫îÊòæÁ§∫ */}
                      {message.role === 'assistant' && rawResponses[message.id] && expandedJson[message.id] && (
                        <div className="mt-3 p-3 bg-muted/50 rounded-lg border">                          <div className="flex items-center gap-2 mb-2">
                            <Code className="w-4 h-4 text-muted-foreground" />
                            <span className="text-sm font-medium text-muted-foreground">ÂéüÂßãAPIÂìçÂ∫î</span>                            <div className="ml-auto flex gap-1">
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => {
                                  // Â§çÂà∂Êà™Êñ≠ÂêéÁöÑJSON
                                  const processJsonForDisplay = (obj: any): any => {
                                    if (typeof obj !== 'object' || obj === null) return obj
                                    
                                    const processed: any = Array.isArray(obj) ? [] : {}
                                    
                                    for (const [key, value] of Object.entries(obj)) {
                                      if (typeof value === 'string') {
                                        if (
                                          (key.includes('image') || key.includes('data_uri') || key.includes('base64')) && 
                                          value.length > 100
                                        ) {
                                          processed[key] = value.substring(0, 100) + `... [Â∑≤Êà™Êñ≠ÔºåÂéüÈïøÂ∫¶: ${value.length}]`
                                        } else {
                                          processed[key] = value
                                        }
                                      } else if (typeof value === 'object' && value !== null) {
                                        processed[key] = processJsonForDisplay(value)
                                      } else {
                                        processed[key] = value
                                      }
                                    }
                                    
                                    return processed
                                  }
                                  
                                  const processedData = processJsonForDisplay(rawResponses[message.id])
                                  navigator.clipboard.writeText(JSON.stringify(processedData, null, 2))
                                  toast.success('Êà™Êñ≠ÂêéÁöÑJSONÂ∑≤Â§çÂà∂')
                                }}
                                className="h-6 px-2 text-xs"
                                title="Â§çÂà∂Êà™Êñ≠ÂêéÁöÑJSONÔºàÂõæÁâáÊï∞ÊçÆÂ∑≤ÁÆÄÂåñÔºâ"
                              >
                                <Copy className="w-3 h-3 mr-1" />
                                Â§çÂà∂Êà™Êñ≠Áâà
                              </Button>
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => {
                                  const jsonString = JSON.stringify(rawResponses[message.id], null, 2)
                                  navigator.clipboard.writeText(jsonString)
                                  toast.success('ÂéüÂßãJSONÂ∑≤Â§çÂà∂')
                                }}
                                className="h-6 px-2 text-xs"
                                title="Â§çÂà∂ÂéüÂßãÂÆåÊï¥ÁöÑJSONÔºàÂåÖÂê´ÂÆåÊï¥Êï∏ÊìöÔºâ"
                              >
                                <Copy className="w-3 h-3 mr-1" />
                                Â§çÂà∂ÂéüÂßãÁâà
                              </Button>
                            </div>
                          </div>                          <div className="text-xs bg-background p-3 rounded border overflow-x-auto max-h-96 overflow-y-auto">
                            {/* ÊòæÁ§∫ÂéüÂßãÂÆåÊï¥ÁöÑJSON */}
                            <textarea 
                              readOnly
                              className="w-full h-full bg-transparent border-none resize-none text-muted-foreground font-mono text-xs"
                              style={{ minHeight: '100px', maxHeight: '300px' }}
                              value={JSON.stringify(rawResponses[message.id], null, 2)}
                            />
                          </div>
                        </div>
                      )}</div>
                  </div>
                </div>
                </MessageErrorBoundary>
              ))}
              
              {/* Loading State */}
              {isLoading && (
                <div className="py-6">
                  <div className="flex gap-4">
                    <div className="w-8 h-8 bg-muted rounded-full flex items-center justify-center border">
                      <Bot className="w-4 h-4 text-muted-foreground" />
                    </div>
                    <div className="flex-1 space-y-2">
                      <div className="text-sm font-medium text-foreground">AIÂä©Êâã</div>
                      <div className="flex items-center gap-2">
                        <div className="flex items-center gap-1">
                          <div className="w-2 h-2 bg-muted-foreground rounded-full animate-bounce"></div>
                          <div className="w-2 h-2 bg-muted-foreground rounded-full animate-bounce [animation-delay:0.1s]"></div>
                          <div className="w-2 h-2 bg-muted-foreground rounded-full animate-bounce [animation-delay:0.2s]"></div>
                        </div>
                        <span className="text-sm text-muted-foreground">Ê≠£Âú®ÊÄùËÄÉ...</span>
                      </div>
                    </div>
                  </div>
                </div>
              )}
              
              <div ref={messagesEndRef} />
            </div>
          )}
        </div>        {/* Input Area */}
        <div className="border-t border-border bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
          <div className="max-w-4xl mx-auto p-4">
            {/* Scroll to bottom button */}            <div className={`
              fixed bottom-24 left-1/2 transform -translate-x-1/2 z-50
              transition-all duration-500 ease-in-out
              ${showScrollToBottom 
                ? 'opacity-100 translate-y-0 pointer-events-auto' 
                : 'opacity-0 translate-y-4 pointer-events-none'
              }
            `}>
              <Button
                onClick={scrollToBottom}
                className="
                  flex items-center gap-2 px-4 py-2 h-10
                  bg-background/80 backdrop-blur-md 
                  border border-border/50 
                  rounded-full shadow-lg hover:shadow-xl 
                  transition-all duration-300 ease-out
                  hover:bg-background/90 hover:scale-105
                  text-foreground hover:text-foreground
                  font-medium text-sm
                "
                variant="ghost"
              >
                <ArrowDown className="w-4 h-4" />
                <span>ÂõûÂà∞Â∫ïÈÉ®</span>
              </Button>
            </div>

            <div className="relative">
              {/* Modern input area with Morphic-style rounded design */}
              <div className="relative flex w-full bg-muted/30 rounded-3xl border border-input shadow-sm">                <textarea
                  ref={textareaRef}
                  value={input}
                  onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => setInput(e.target.value)}
                  onKeyDown={handleKeyDown}
                  onCompositionStart={handleCompositionStart}
                  onCompositionUpdate={handleCompositionUpdate}
                  onCompositionEnd={handleCompositionEnd}
                  placeholder="ÂèëÈÄÅÊ∂àÊÅØ..."
                  className="w-full min-h-12 max-h-32 px-4 py-3 pr-12 bg-transparent border-none resize-none focus-visible:outline-none placeholder:text-muted-foreground text-foreground rounded-3xl"
                  disabled={isLoading}
                  rows={1}/>
                <div className="absolute right-2 top-1/2 -translate-y-1/2 flex gap-1">
                  {isLoading && (
                    <Button
                      onClick={cancelRequest}
                      variant="outline"
                      className="h-8 w-8 rounded-full bg-background border-border"
                      size="icon"
                    >
                      <span className="text-xs">‚úï</span>
                    </Button>
                  )}
                  <Button
                    onClick={sendMessage}
                    disabled={!input.trim() || isLoading}
                    className={cn(
                      "h-8 w-8 rounded-full transition-all",
                      isLoading && "opacity-50 cursor-not-allowed"
                    )}
                    size="icon"
                  >
                    {isLoading ? (
                      <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                    ) : (
                      <Send className="w-4 h-4" />
                    )}
                  </Button>
                </div>
              </div>
            </div>
              {/* Status Bar */}
            <div className="flex items-center justify-center mt-3 text-xs text-muted-foreground">
              <div className="flex items-center gap-2">
                <span>{useAgent ? 'AgentÊ®°Âºè' : 'ChatÊ®°Âºè'}</span>
                <span>‚Ä¢</span>
                <span>Ê®°Âûã: {selectedModel}</span>
                <span>‚Ä¢</span>
                <span className="flex items-center gap-1">
                  <div className={cn(
                    "w-1.5 h-1.5 rounded-full",
                    apiStatus === 'connected' && "bg-green-500",
                    apiStatus === 'disconnected' && "bg-red-500",
                    apiStatus === 'testing' && "bg-yellow-500 animate-pulse"
                  )} />
                  {API_BASE_URL.replace('http://', '')}
                </span>
                {isLoading && (
                  <>
                    <span>‚Ä¢</span>
                    <span className="flex items-center gap-1">
                      <div className="w-1.5 h-1.5 bg-blue-500 rounded-full animate-pulse" />
                      ËôïÁêÜ‰∏≠...
                    </span>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

// Error Boundary Component for individual messages
const MessageErrorBoundary = ({ children, messageId }: { children: React.ReactNode, messageId: string }) => {
  const [hasError, setHasError] = useState(false)
  
  useEffect(() => {
    setHasError(false)
  }, [messageId])
  
  if (hasError) {
    return (
      <div className="bg-destructive/10 border border-destructive/20 rounded-lg p-4 text-center">
        <div className="text-destructive text-sm">
          ‚ùå Ê∂àÊÅØÊ∏≤ÊüìÂá∫ÈåØ
        </div>
        <Button 
          variant="outline" 
          size="sm" 
          className="mt-2"
          onClick={() => setHasError(false)}
        >
          ÈáçË©¶
        </Button>
      </div>
    )
  }
  
  try {
    return <>{children}</>
  } catch (error) {
    console.error('Message render error:', error)
    setHasError(true)
    return null
  }
}

// ÂúñÁâáÁµÑ‰ª∂ - ÈáçÊñ∞Ë®≠Ë®àÔºåÁ∞°ÂåñÈÇèËºØÔºåÂ∞àÊ≥®MongoDBÂúñÁâáURLËôïÁêÜ
const ImageComponent = (props: React.ImgHTMLAttributes<HTMLImageElement>): React.ReactElement | null => {
  const [currentSrc, setCurrentSrc] = useState<string>(typeof props.src === 'string' ? props.src : '');
  const [imageSrc, setImageSrc] = useState<string>('');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string>('');
  const blobUrlRef = useRef<string | null>(null);
  const staticImageCache = useRef<Record<string, string>>({});
  
  const alt = props.alt || 'ÁîüÊàêÁöÑÂúñÁâá';
  
  // ÂΩìprops.srcÂèòÂåñÊó∂Êõ¥Êñ∞currentSrc
  useEffect(() => {
    if (typeof props.src === 'string' && props.src !== currentSrc) {
      setCurrentSrc(props.src);
      
      // Ê∏ÖÁêÜ‰πãÂâçÁöÑblob URL
      if (blobUrlRef.current) {
        try {
          URL.revokeObjectURL(blobUrlRef.current);
          console.log('üßπ Revoked previous blob URL due to src change');
          blobUrlRef.current = null;
        } catch (e) {
          console.error('‚ùå Failed to revoke previous blob URL:', e);
        }
      }
    }  }, [props.src, currentSrc]);  // ÂõæÁâáÂ§ÑÁêÜÈÄªËæë
  useEffect(() => {
    // Ê™¢Êü•srcÊòØÂê¶ÁÇ∫Á©∫ÊàñÁÑ°Êïà
    if (!currentSrc || currentSrc.trim() === '' || currentSrc === '#' || currentSrc === 'undefined' || currentSrc === 'null') {
      console.warn('Empty or invalid image src detected, skipping processing:', currentSrc);
      setIsLoading(false);
      return;
    }
    
    // Ê£ÄÊü•ÊòØÂê¶ÊòØattachmentÁõ∏ÂÖ≥ÁöÑÂç†‰ΩçÁ¨¶ÔºàÊó†ÊïàÁöÑÂõæÁâáÂºïÁî®Ôºâ
    if (currentSrc === 'attachment_url' || currentSrc === 'attachment' || 
        (currentSrc.includes('attachment') && !currentSrc.startsWith('data:') && !currentSrc.startsWith('http') && !currentSrc.startsWith('/api/'))) {
      console.warn('Invalid attachment placeholder detected, skipping:', currentSrc);
      setIsLoading(false);
      return;
    }
    
    // Ê£ÄÊü•ÊòØÂê¶ÊòØURLÁºñÁ†ÅÁöÑÊñáÊú¨Ôºà‰∏çÊòØÂõæÁâáÔºâ
    if (currentSrc.includes('%') && !currentSrc.startsWith('data:') && !currentSrc.startsWith('/api/') && !currentSrc.startsWith('http')) {
      try {
        const decoded = decodeURIComponent(currentSrc);
        console.warn('Detected URL encoded text (not image), skipping:', decoded);
        setIsLoading(false);
        return;
      } catch (e) {
        console.warn('Failed to decode URL encoded string:', currentSrc);
        setIsLoading(false);
        return;
      }
    }
    
    // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÊòéÊòæÁöÑÈùûÂõæÁâáÂÜÖÂÆπÔºà‰∏≠Êñá„ÄÅËã±ÊñáÊñáÊú¨Á≠âÔºâ
    const textPatterns = [
      /[\u4e00-\u9fff]/, // ‰∏≠ÊñáÂ≠óÁ¨¶
      /^[a-zA-Z\s]+$/, // Á∫ØËã±ÊñáÊñáÊú¨
      /Âú®ÂõûÂ§ç‰∏≠Â±ïÁ§∫/, // ÁâπÂÆöÊñáÊú¨Ê®°Âºè
    ];
    
    for (const pattern of textPatterns) {
      if (pattern.test(currentSrc)) {
        console.warn('Detected text content (not image), skipping:', currentSrc.substring(0, 50));
        setIsLoading(false);
        return;
      }
    }
    // Ê£ÄÊü•ÁºìÂ≠ò
    if (staticImageCache.current[currentSrc]) {
      console.log('üìã Using cached processed image URL');
      setImageSrc(staticImageCache.current[currentSrc]);
      setIsLoading(false);
      return;
    }
    
    const processImageAsync = async () => {
      try {
        setIsLoading(true);
        setError('');
        
        let processedSrc = currentSrc;        // 1. Â§ÑÁêÜMongoDB APIÂõæÁâáURL (‰ºòÂÖàÁ∫ßÊúÄÈ´ò)
        if (processedSrc.startsWith('/api/v1/images/') || processedSrc.includes('/api/v1/images/')) {
          console.log('üîó Processing MongoDB image URL:', processedSrc.substring(0, 50));
          if (processedSrc.startsWith('/')) {
            // Âè™ÊúâÁõ∏ÂØπË∑ØÂæÑÊâçÈúÄË¶ÅËΩ¨Êç¢
            processedSrc = `${API_BASE_URL}${processedSrc}`;
          }
          // Â¶ÇÊûúÂ∑≤ÁªèÊòØÂÆåÊï¥URLÔºåÁõ¥Êé•‰ΩøÁî®
          staticImageCache.current[currentSrc] = processedSrc;
          setImageSrc(processedSrc);
          setIsLoading(false);
          return;
        }
        
        // 2. Â§ÑÁêÜÂÆåÊï¥ÁöÑdata URI
        if (processedSrc.startsWith('data:image/')) {
          console.log('üì∑ Processing data URI image');
          staticImageCache.current[currentSrc] = processedSrc;
          setImageSrc(processedSrc);
          setIsLoading(false);
          return;
        }
        
        // 3. Â§ÑÁêÜÁ∫Øbase64Â≠óÁ¨¶‰∏≤
        if (processedSrc.match(/^[A-Za-z0-9+/]+=*$/) && processedSrc.length > 50) {
          console.log('üîÑ Converting base64 to data URI');
          processedSrc = `data:image/jpeg;base64,${processedSrc}`;
          staticImageCache.current[currentSrc] = processedSrc;
          setImageSrc(processedSrc);
          setIsLoading(false);
          return;
        }
        
        // 4. Â§ÑÁêÜÂÖ∂‰ªñË∑ØÂæÑ
        if (processedSrc.startsWith('/')) {
          processedSrc = `${window.location.origin}${processedSrc}`;
          staticImageCache.current[currentSrc] = processedSrc;
          setImageSrc(processedSrc);
          setIsLoading(false);
          return;
        }
        
        // 5. Êó†ÊïàÊ†ºÂºè
        console.warn('‚ö†Ô∏è Unsupported image format:', processedSrc.substring(0, 50));
        setError('‰∏çÊîØÊåÅÁöÑÂúñÁâáÊ†ºÂºè');
        setIsLoading(false);
        
      } catch (err) {
        console.error('‚ùå Error processing image:', err);
        setError('ÂúñÁâáËôïÁêÜÂ§±Êïó');
        setIsLoading(false);
      }
    };
    
    processImageAsync();
    
    // Ê∏ÖÁêÜÂáΩÊï∞
    return () => {
      if (blobUrlRef.current) {
        try {
          URL.revokeObjectURL(blobUrlRef.current);
          console.log('üßπ Blob URL revoked on cleanup');
          blobUrlRef.current = null;
        } catch (e) {
          console.error('‚ùå Failed to revoke blob URL:', e);
        }
      }
    };  }, [currentSrc]);  // Êó©ÊúüËøîÂõûÊ£ÄÊü•ÔºàÂøÖÈ°ªÂú®ÊâÄÊúâhooks‰πãÂêéÔºâ
  if (!currentSrc || currentSrc.trim() === '' || currentSrc === '#' || currentSrc === 'undefined' || currentSrc === 'null') {
    console.warn('Empty or invalid image src detected, skipping render:', currentSrc);
    return null;
  }
  
  // Ê£ÄÊü•ÊòØÂê¶ÊòØattachmentÁõ∏ÂÖ≥ÁöÑÂç†‰ΩçÁ¨¶ÔºàÊó†ÊïàÁöÑÂõæÁâáÂºïÁî®Ôºâ
  if (currentSrc === 'attachment_url' || currentSrc === 'attachment' || 
      (currentSrc.includes('attachment') && !currentSrc.startsWith('data:') && !currentSrc.startsWith('http') && !currentSrc.startsWith('/api/'))) {
    console.warn('Invalid attachment placeholder detected, skipping render:', currentSrc);
    return null;
  }
  
  // Ê£ÄÊü•ÊòØÂê¶ÊòØURLÁºñÁ†ÅÁöÑÊñáÊú¨ÊàñÁ∫ØÊñáÊú¨Ôºà‰∏çÊòØÂõæÁâáÔºâ
  if (currentSrc.includes('%') && !currentSrc.startsWith('data:') && !currentSrc.startsWith('/api/') && !currentSrc.startsWith('http')) {
    console.warn('URL encoded text detected, skipping render:', currentSrc);
    return null;
  }
  
  // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´‰∏≠ÊñáÊàñÊòéÊòæÁöÑÊñáÊú¨ÂÜÖÂÆπ
  if (/[\u4e00-\u9fff]/.test(currentSrc) || /^[a-zA-Z\s]+$/.test(currentSrc)) {
    console.warn('Text content detected, skipping render:', currentSrc.substring(0, 50));
    return null;
  }
  
  // Ê∏≤ÊüìÁä∂ÊÄÅ
  if (isLoading) {
    return (
      <span className="inline-block">
        <span className="bg-muted px-3 py-2 rounded-lg border text-center inline-flex items-center gap-2">
          <span className="w-4 h-4 border-2 border-muted-foreground border-t-transparent rounded-full animate-spin"></span>
          <span className="text-sm text-muted-foreground">Ê≠£Âú®Âä†ËºâÂúñÁâá...</span>
        </span>
      </span>
    )
  }
  
  if (error) {
    return (
      <span className="inline-block">
        <span className="bg-muted px-3 py-2 rounded-lg border border-destructive/20 text-center">
          <span className="text-destructive text-sm">üñºÔ∏è {error}</span>
          <br />
          <span className="text-muted-foreground text-xs">
            ÂéüÂßãÊï∏Êìö: {currentSrc.substring(0, 30)}...
          </span>
        </span>
      </span>
    )
  }
  
  return (
    <img 
      src={imageSrc} 
      alt={alt} 
      className="max-w-full h-auto rounded-lg shadow-sm border" 
      loading="lazy"
      onError={(e) => {
        const target = e.target as HTMLImageElement;
        console.error('‚ùå Image failed to load:', target.src.substring(0, 100));
        setError(`ÂúñÁâáÂä†ËºâÂ§±Êïó: ${target.src.startsWith('blob:') ? 'Blob URLÈåØË™§' : 'ËºâÂÖ•Â§±Êïó'}`);
      }}
      onLoad={() => {
        console.log('‚úÖ Image loaded successfully:', imageSrc.substring(0, 50));
      }}
      style={{ maxHeight: '80vh' }}
    />
  )
}
